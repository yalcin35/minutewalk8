{"version":3,"file":"BR-G7xfO.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/select.js"],"sourcesContent":["import { effect } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { untrack } from '../../../runtime.js';\nimport { is } from '../../../proxy.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} [mounting]\n */\nexport function select_option(select, value, mounting) {\n\tif (select.multiple) {\n\t\treturn select_options(select, value);\n\t}\n\n\tfor (var option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @template V\n * @param {HTMLSelectElement} select\n * @param {() => V} [get_value]\n */\nexport function init_select(select, get_value) {\n\tlet mounting = true;\n\teffect(() => {\n\t\tif (get_value) {\n\t\t\tselect_option(select, untrack(get_value), mounting);\n\t\t}\n\t\tmounting = false;\n\n\t\tvar observer = new MutationObserver(() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = select.__value;\n\t\t\tselect_option(select, value);\n\t\t\t// Deliberately don't update the potential binding value,\n\t\t\t// the model should be preserved unless explicitly changed\n\t\t});\n\n\t\tobserver.observe(select, {\n\t\t\t// Listen to option element changes\n\t\t\tchildList: true,\n\t\t\tsubtree: true, // because of <optgroup>\n\t\t\t// Listen to option element value attribute changes\n\t\t\t// (doesn't get notified of select value changes,\n\t\t\t// because that property is not reflected as an attribute)\n\t\t\tattributes: true,\n\t\t\tattributeFilter: ['value']\n\t\t});\n\n\t\treturn () => {\n\t\t\tobserver.disconnect();\n\t\t};\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_select_value(select, get, set = get) {\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', (is_reset) => {\n\t\tvar query = is_reset ? '[selected]' : ':checked';\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option =\n\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tset(value);\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get();\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tset(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\t// don't pass get_value, we already initialize it in the effect above\n\tinit_select(select);\n}\n\n/**\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n */\nfunction select_options(select, value) {\n\tfor (var option of select.options) {\n\t\t// @ts-ignore\n\t\toption.selected = ~value.indexOf(get_option_value(option));\n\t}\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n"],"names":[],"mappings":";;AAYO,SAAS,cAAc,QAAQ,OAAO,UAAU;AACtD,MAAI,OAAO,UAAU;AACpB,WAAO,eAAe,QAAQ,KAAK;AAAA,EACrC;AAEC,WAAS,UAAU,OAAO,SAAS;AAClC,QAAI,eAAe,iBAAiB,MAAM;AAC1C,QAAI,GAAG,cAAc,KAAK,GAAG;AAC5B,aAAO,WAAW;AAClB;AAAA,IACH;AAAA,EACA;AAEC,MAAI,CAAC,YAAY,UAAU,QAAW;AACrC,WAAO,gBAAgB;AAAA,EACzB;AACA;AAYO,SAAS,YAAY,QAAQ,WAAW;AAC9C,MAAI,WAAW;AACf,SAAO,MAAM;AACZ,QAAI,WAAW;AACd,oBAAc,QAAQ,QAAQ,SAAS,GAAG,QAAQ;AAAA,IACrD;AACE,eAAW;AAEX,QAAI,WAAW,IAAI,iBAAiB,MAAM;AAEzC,UAAI,QAAQ,OAAO;AACnB,oBAAc,QAAQ,KAAK;AAAA,IAG9B,CAAG;AAED,aAAS,QAAQ,QAAQ;AAAA;AAAA,MAExB,WAAW;AAAA,MACX,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,MAIT,YAAY;AAAA,MACZ,iBAAiB,CAAC,OAAO;AAAA,IAC5B,CAAG;AAED,WAAO,MAAM;AACZ,eAAS,WAAY;AAAA,IACrB;AAAA,EACH,CAAE;AACF;AAQO,SAAS,kBAAkB,QAAQ,KAAK,MAAM,KAAK;AACzD,MAAI,WAAW;AAEf,kCAAgC,QAAQ,UAAU,CAAC,aAAa;AAC/D,QAAI,QAAQ,WAAW,eAAe;AAEtC,QAAI;AAEJ,QAAI,OAAO,UAAU;AACpB,cAAQ,CAAA,EAAG,IAAI,KAAK,OAAO,iBAAiB,KAAK,GAAG,gBAAgB;AAAA,IACvE,OAAS;AAEN,UAAI,kBACH,OAAO,cAAc,KAAK;AAAA,MAE1B,OAAO,cAAc,wBAAwB;AAC9C,cAAQ,mBAAmB,iBAAiB,eAAe;AAAA,IAC9D;AAEE,QAAI,KAAK;AAAA,EACX,CAAE;AAGD,SAAO,MAAM;AACZ,QAAI,QAAQ,IAAK;AACjB,kBAAc,QAAQ,OAAO,QAAQ;AAGrC,QAAI,YAAY,UAAU,QAAW;AAEpC,UAAI,kBAAkB,OAAO,cAAc,UAAU;AACrD,UAAI,oBAAoB,MAAM;AAC7B,gBAAQ,iBAAiB,eAAe;AACxC,YAAI,KAAK;AAAA,MACb;AAAA,IACA;AAGE,WAAO,UAAU;AACjB,eAAW;AAAA,EACb,CAAE;AAGD,cAAY,MAAM;AACnB;AAOA,SAAS,eAAe,QAAQ,OAAO;AACtC,WAAS,UAAU,OAAO,SAAS;AAElC,WAAO,WAAW,CAAC,MAAM,QAAQ,iBAAiB,MAAM,CAAC;AAAA,EAC3D;AACA;AAGA,SAAS,iBAAiB,QAAQ;AAEjC,MAAI,aAAa,QAAQ;AACxB,WAAO,OAAO;AAAA,EAChB,OAAQ;AACN,WAAO,OAAO;AAAA,EAChB;AACA;","x_google_ignoreList":[0]}