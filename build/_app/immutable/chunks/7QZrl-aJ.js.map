{"version":3,"file":"7QZrl-aJ.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/input.js"],"sourcesContent":["import { DEV } from 'esm-env';\nimport { render_effect, teardown } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport * as e from '../../../errors.js';\nimport { is } from '../../../proxy.js';\nimport { queue_micro_task } from '../../task.js';\nimport { hydrating } from '../../hydration.js';\nimport { untrack } from '../../../runtime.js';\nimport { is_runes } from '../../../context.js';\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_value(input, get, set = get) {\n\tvar runes = is_runes();\n\n\tlisten_to_event_and_reset_event(input, 'input', (is_reset) => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\t/** @type {any} */\n\t\tvar value = is_reset ? input.defaultValue : input.value;\n\t\tvalue = is_numberlike_input(input) ? to_number(value) : value;\n\t\tset(value);\n\n\t\t// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,\n\t\t// because we use mutable state which ensures the render effect always runs)\n\t\tif (runes && value !== (value = get())) {\n\t\t\tvar start = input.selectionStart;\n\t\t\tvar end = input.selectionEnd;\n\n\t\t\t// the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\n\t\t\t// Restore selection\n\t\t\tif (end !== null) {\n\t\t\t\tinput.selectionStart = start;\n\t\t\t\tinput.selectionEnd = Math.min(end, input.value.length);\n\t\t\t}\n\t\t}\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\t(hydrating && input.defaultValue !== input.value) ||\n\t\t// If defaultValue is set, then value == defaultValue\n\t\t// TODO Svelte 6: remove input.value check and set to empty string?\n\t\t(untrack(get) == null && input.value)\n\t) {\n\t\tset(is_numberlike_input(input) ? to_number(input.value) : input.value);\n\t}\n\n\trender_effect(() => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\tvar value = get();\n\n\t\tif (is_numberlike_input(input) && value === to_number(input.value)) {\n\t\t\t// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)\n\t\t\treturn;\n\t\t}\n\n\t\tif (input.type === 'date' && !value && !input.value) {\n\t\t\t// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)\n\t\t\t// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)\n\t\t\treturn;\n\t\t}\n\n\t\t// don't set the value of the input if it's the same to allow\n\t\t// minlength to work properly\n\t\tif (value !== input.value) {\n\t\t\t// @ts-expect-error the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\t\t}\n\t});\n}\n\n/** @type {Set<HTMLInputElement[]>} */\nconst pending = new Set();\n\n/**\n * @param {HTMLInputElement[]} inputs\n * @param {null | [number]} group_index\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_group(inputs, group_index, input, get, set = get) {\n\tvar is_checkbox = input.getAttribute('type') === 'checkbox';\n\tvar binding_group = inputs;\n\n\t// needs to be let or related code isn't treeshaken out if it's always false\n\tlet hydration_mismatch = false;\n\n\tif (group_index !== null) {\n\t\tfor (var index of group_index) {\n\t\t\t// @ts-expect-error\n\t\t\tbinding_group = binding_group[index] ??= [];\n\t\t}\n\t}\n\n\tbinding_group.push(input);\n\n\tlisten_to_event_and_reset_event(\n\t\tinput,\n\t\t'change',\n\t\t() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = input.__value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t}\n\n\t\t\tset(value);\n\t\t},\n\t\t// TODO better default value handling\n\t\t() => set(is_checkbox ? [] : null)\n\t);\n\n\trender_effect(() => {\n\t\tvar value = get();\n\n\t\t// If we are hydrating and the value has since changed, then use the update value\n\t\t// from the input instead.\n\t\tif (hydrating && input.defaultChecked !== input.checked) {\n\t\t\thydration_mismatch = true;\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_checkbox) {\n\t\t\tvalue = value || [];\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = value.includes(input.__value);\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = is(input.__value, value);\n\t\t}\n\t});\n\n\tteardown(() => {\n\t\tvar index = binding_group.indexOf(input);\n\n\t\tif (index !== -1) {\n\t\t\tbinding_group.splice(index, 1);\n\t\t}\n\t});\n\n\tif (!pending.has(binding_group)) {\n\t\tpending.add(binding_group);\n\n\t\tqueue_micro_task(() => {\n\t\t\t// necessary to maintain binding group order in all insertion scenarios\n\t\t\tbinding_group.sort((a, b) => (a.compareDocumentPosition(b) === 4 ? -1 : 1));\n\t\t\tpending.delete(binding_group);\n\t\t});\n\t}\n\n\tqueue_micro_task(() => {\n\t\tif (hydration_mismatch) {\n\t\t\tvar value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t} else {\n\t\t\t\tvar hydration_input = binding_group.find((input) => input.checked);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvalue = hydration_input?.__value;\n\t\t\t}\n\n\t\t\tset(value);\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_checked(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', (is_reset) => {\n\t\tvar value = is_reset ? input.defaultChecked : input.checked;\n\t\tset(value);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the update value from the input instead.\n\t\t(hydrating && input.defaultChecked !== input.checked) ||\n\t\t// If defaultChecked is set, then checked == defaultChecked\n\t\tuntrack(get) == null\n\t) {\n\t\tset(input.checked);\n\t}\n\n\trender_effect(() => {\n\t\tvar value = get();\n\t\tinput.checked = Boolean(value);\n\t});\n}\n\n/**\n * @template V\n * @param {Array<HTMLInputElement>} group\n * @param {V} __value\n * @param {boolean} checked\n * @returns {V[]}\n */\nfunction get_binding_group_value(group, __value, checked) {\n\tvar value = new Set();\n\n\tfor (var i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) {\n\t\t\t// @ts-ignore\n\t\t\tvalue.add(group[i].__value);\n\t\t}\n\t}\n\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement} input\n */\nfunction is_numberlike_input(input) {\n\tvar type = input.type;\n\treturn type === 'number' || type === 'range';\n}\n\n/**\n * @param {string} value\n */\nfunction to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => FileList | null} get\n * @param {(value: FileList | null) => void} set\n */\nexport function bind_files(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', () => {\n\t\tset(input.files);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\thydrating &&\n\t\tinput.files\n\t) {\n\t\tset(input.files);\n\t}\n\n\trender_effect(() => {\n\t\tinput.files = get();\n\t});\n}\n"],"names":["index","input"],"mappings":"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","x_google_ignoreList":[0]}